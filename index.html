<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MS Digital Brochure — Fixed Flipbook</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box; -webkit-tap-highlight-color:transparent}
    body{font-family: Arial, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, sans-serif; background: linear-gradient(135deg,#ff6b6b 0%,#a50034 100%); min-height:100vh; display:flex; align-items:center; justify-content:center; padding:20px; color:#111}
    .wrap{width:min(100%,900px)}

    .flipbook{position:relative; width:100%; aspect-ratio:1.414; background:#fff; border-radius:8px; box-shadow:0 20px 40px rgba(0,0,0,.3); overflow:visible; perspective:1500px; transform-style:preserve-3d; margin:0 auto}

    .spread{position:relative; inset:0; display:flex; height:100%; transform-style:preserve-3d}

    .page-container{position:relative; width:50%; height:100%; transform-style:preserve-3d}

    .page{position:absolute; inset:0; background-position:center; background-size:cover; background-repeat:no-repeat; backface-visibility:hidden; transform-style:preserve-3d}
    .page.front{z-index:20}
    .page.back{z-index:10; transform:rotateY(180deg)}
    .page.blank{background:#fff}

    .page-container.left{transform-origin:right center; border-right:1px solid rgba(0,0,0,.06)}
    .page-container.right{transform-origin:left center}

    /* flipping states are applied to containers */
    .page-container.flipping{transition:transform .8s cubic-bezier(0.25,0.46,0.45,0.94); z-index:1000}
    .page-container.flip-left{transform:rotateY(180deg)}      /* turning backward */
    .page-container.flip-right{transform:rotateY(-180deg)}    /* turning forward */

    /* subtle shadow while flipping */
    .page-container.flipping::after{content:'';position:absolute;inset:0;background:linear-gradient(90deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0) 100%);opacity:0;transition:opacity .4s;pointer-events:none}
    .page-container.flipping.shadow::after{opacity:1}

    .flipbook::before{content:'';position:absolute;top:0;bottom:0;left:50%;width:2px;transform:translateX(-1px);background:linear-gradient(180deg, rgba(0,0,0,.12), rgba(0,0,0,0) 40%, rgba(0,0,0,.12));opacity:.25;pointer-events:none;z-index:500}

    .controls{display:flex;justify-content:center;align-items:center;gap:12px;margin-top:20px}
    .nav-btn{background:#fff;color:#e60012;border:none;padding:12px 20px;border-radius:999px;cursor:pointer;font-size:15px;font-weight:700;transition:transform .15s ease,box-shadow .15s ease;box-shadow:0 6px 18px rgba(230,0,18,.35)}
    .nav-btn:hover{transform:translateY(-1px);box-shadow:0 10px 24px rgba(230,0,18,.45)}
    .nav-btn:disabled{opacity:.5;cursor:not-allowed;transform:none;box-shadow:none}

    .loading{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(255,255,255,.95);z-index:2000;gap:10px}
    .spinner{width:30px;height:30px;border:3px solid #f3f3f3;border-top:3px solid #e60012;border-radius:50%;animation:spin .8s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    @media (max-width:768px){.wrap{width:90vw}.nav-btn{padding:10px 16px;font-size:14px}}
    @media (prefers-reduced-motion:reduce){.page-container{transition:none !important}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="flipbook" id="flipbook" aria-label="Flipbook">
      <div class="loading" id="loading"><div class="spinner"></div><div>Loading pages…</div></div>
    </div>

    <div class="controls" aria-label="Pagination controls">
      <button class="nav-btn" id="prevBtn">← Previous</button>
      <button class="nav-btn" id="nextBtn">Next →</button>
    </div>
  </div>

  <script>
    /* ---------------- CONFIG ---------------- */
    const CONFIG = {
      imagePrefix: 'Pg',
      imageExtensions: ['jpg','jpeg','png','webp'],
      maxPagesToCheck: 200,
      loadingTimeout: 3000,
      preloadAhead: 2,
      animationDuration: 800
    };

    /* ---------------- STATE ---------------- */
    let pages = [null]; // keep index aligned with page numbers: pages[1] = Pg1
    let totalImages = 0;
    let currentSpread = 0; // 0 = cover spread (left blank, right = Pg1)
    let isAnimating = false;

    const $ = s => document.querySelector(s);
    const flipbook = $('#flipbook'), loading = $('#loading');
    const prevBtn = $('#prevBtn'), nextBtn = $('#nextBtn');

    prevBtn.addEventListener('click', previousPage);
    nextBtn.addEventListener('click', nextPage);

    document.addEventListener('keydown', e=>{
      if(['ArrowLeft','ArrowUp'].includes(e.key)){ e.preventDefault(); previousPage(); }
      if(['ArrowRight','ArrowDown'].includes(e.key)){ e.preventDefault(); nextPage(); }
    });

    flipbook.addEventListener('contextmenu', e=>e.preventDefault());
    document.addEventListener('dragstart', e=>e.preventDefault());

    /* ---------------- INIT ---------------- */
    async function init(){
      const detected = await detectPages();
      if(detected.length === 0){
        loading.innerHTML = `<div style="color:#e74c3c;text-align:center"><strong>No pages found</strong><br>Place images in the same folder as this HTML file and name them: <code>${CONFIG.imagePrefix}1.jpg</code>, <code>${CONFIG.imagePrefix}2.jpg</code>, etc.<br><small>Supported formats: ${CONFIG.imageExtensions.join(', ')}</small></div>`;
        updateControls();
        return;
      }

      // Reset and align indices
      pages = [null];
      detected.forEach(p => pages.push(p.path));
      totalImages = pages.length - 1;

      // Build DOM once
      buildSpread();
      loading.style.display = 'none';
      updateControls();
      preloadAround(currentSpread);
    }

    function buildSpread(){
      flipbook.innerHTML = '';
      const spread = document.createElement('div'); spread.className = 'spread';

      const leftContainer = document.createElement('div'); leftContainer.className = 'page-container left'; leftContainer.id = 'leftContainer';
      const rightContainer = document.createElement('div'); rightContainer.className = 'page-container right'; rightContainer.id = 'rightContainer';

      spread.appendChild(leftContainer);
      spread.appendChild(rightContainer);
      flipbook.appendChild(spread);

      // initial render
      updateSpreadContent();

      // Ensure transitions duration matches config
      leftContainer.style.transitionDuration = rightContainer.style.transitionDuration = (CONFIG.animationDuration / 1000) + 's';
    }

    /* ---------------- RENDERING / INDEX MATH ----------------
       currentSpread maps to page numbers like this:
       spread 0 => left: 0 (blank), right: 1
       spread 1 => left: 2, right: 3
       spread 2 => left: 4, right: 5
       ...
       This keeps pages in natural reading order: Pg1 on right (cover)
    */
    function updateSpreadContent(){
      const leftContainer = $('#leftContainer');
      const rightContainer = $('#rightContainer');
      leftContainer.innerHTML = '';
      rightContainer.innerHTML = '';

      const leftIndex = currentSpread * 2;           // could be 0 for cover blank
      const rightIndex = currentSpread * 2 + 1;

      // For each container we decide what the front and back images are.
      // - Right container: front = rightIndex, back = rightIndex + 2 (next right page when turning forward)
      // - Left container: front = leftIndex, back = leftIndex - 2 (previous right page when turning backward)

      createPagePair(leftContainer, leftIndex, leftIndex - 2);
      createPagePair(rightContainer, rightIndex, rightIndex + 2);
    }

    function createPagePair(container, frontIndex, backIndex){
      const front = document.createElement('div'); front.className = 'page front';
      const back = document.createElement('div'); back.className = 'page back';

      // Front side
      if(frontIndex > 0 && frontIndex <= totalImages && pages[frontIndex]){
        front.style.backgroundImage = `url('${pages[frontIndex]}')`;
      } else {
        front.classList.add('blank');
      }

      // Back side — the image that appears on the reverse of this sheet during flip
      if(backIndex > 0 && backIndex <= totalImages && pages[backIndex]){
        back.style.backgroundImage = `url('${pages[backIndex]}')`;
        // Keep back rotated 180deg so that when the container flips, it reads in the correct direction
        back.style.transform = 'rotateY(180deg)';
      } else {
        back.classList.add('blank');
        back.style.transform = 'rotateY(180deg)';
      }

      container.appendChild(front);
      container.appendChild(back);
    }

    /* ---------------- NAV ---------------- */
    function nextPage(){
      if(isAnimating) return;
      const maxSpreads = Math.ceil((totalImages) / 2);
      if(currentSpread >= maxSpreads - 1) return;

      isAnimating = true; updateControls();

      const rightContainer = $('#rightContainer');
      // Bring the right container to front so it appears on top while flipping
      rightContainer.style.zIndex = 1000;
      rightContainer.classList.add('flipping','shadow');

      // start the rotation
      requestAnimationFrame(()=> rightContainer.classList.add('flip-right'));

      setTimeout(()=>{
        // advance spread, re-render and reset
        currentSpread++;
        updateSpreadContent();
        resetAnimations();
        isAnimating = false; updateControls(); preloadAround(currentSpread);
      }, CONFIG.animationDuration);
    }

    function previousPage(){
      if(isAnimating || currentSpread <= 0) return;
      isAnimating = true; updateControls();

      const leftContainer = $('#leftContainer');
      leftContainer.style.zIndex = 1000;
      leftContainer.classList.add('flipping','shadow');
      requestAnimationFrame(()=> leftContainer.classList.add('flip-left'));

      setTimeout(()=>{
        currentSpread--;
        updateSpreadContent();
        resetAnimations();
        isAnimating = false; updateControls(); preloadAround(currentSpread);
      }, CONFIG.animationDuration);
    }

    function resetAnimations(){
      const containers = [document.getElementById('leftContainer'), document.getElementById('rightContainer')];
      containers.forEach(c=>{
        if(!c) return;
        c.classList.remove('flipping','shadow','flip-left','flip-right');
        c.style.zIndex = '';
      });
    }

    function updateControls(){
      const maxSpreads = Math.ceil((totalImages) / 2);
      prevBtn.disabled = (currentSpread <= 0) || isAnimating;
      nextBtn.disabled = (currentSpread >= maxSpreads - 1) || isAnimating;
    }

    /* ---------------- PRELOAD ---------------- */
    const preloaded = new Set();
    function preloadAround(spread){
      for(let d = -CONFIG.preloadAhead; d <= CONFIG.preloadAhead; d++){
        const s = spread + d;
        const left = s*2; const right = s*2+1;
        [left, right, left+2, right+2].forEach(idx=>{
          if(idx > 0 && idx <= totalImages && pages[idx] && !preloaded.has(pages[idx])){
            const img = new Image(); img.decoding = 'async'; img.src = pages[idx]; preloaded.add(pages[idx]);
          }
        });
      }
    }

    /* ---------------- DISCOVERY ---------------- */
    async function detectPages(){
      const found = [];
      for(let i=1;i<=CONFIG.maxPagesToCheck;i++){
        let picked = null;
        for(const ext of CONFIG.imageExtensions){
          const src = `${CONFIG.imagePrefix}${i}.${ext}`;
          if(await checkImage(src)){ picked = src; break; }
        }
        if(picked) found.push({number:i,path:picked});
        else if(found.length>0) break; // stop after sequence ends
      }
      return found;
    }

    function checkImage(src){
      return new Promise(resolve=>{
        const img = new Image(); let done=false;
        const to = setTimeout(()=>{ if(!done){ done=true; resolve(false);} }, CONFIG.loadingTimeout);
        img.onload = ()=>{ if(!done){ done=true; clearTimeout(to); resolve(true);} };
        img.onerror = ()=>{ if(!done){ done=true; clearTimeout(to); resolve(false);} };
        // cache-bust while loading from file system can be problematic but helps during dev
        img.src = src + `?v=${Date.now()}`;
      });
    }

    init();
  </script>
</body>
</html>
