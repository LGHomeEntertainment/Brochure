<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MS Digital Brochure</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    body{
      font-family: Arial, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, sans-serif;
      background: linear-gradient(135deg,#ff6b6b 0%,#a50034 100%);
      min-height:100vh; display:flex; align-items:center; justify-content:center; padding:20px;
      color:#111; user-select:none;
    }
    .wrap{width:min(100%, 900px)}

    /* 높이 고정: 항상 스프레드(2페이지) 기준 비율 */
    .flipbook{
      position:relative; width:100%; aspect-ratio: 1.414;
      background:#fff; border-radius:8px; box-shadow:0 20px 40px rgba(0,0,0,.3); overflow:hidden;
      perspective: 1500px; transform-style: preserve-3d; margin:0 auto;
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; -webkit-user-drag:none;
    }

    .sheet{ position:absolute; inset:0; visibility:visible; }

    .page{
      position:absolute; top:0; bottom:0; width:50%; overflow:hidden; background:#fff;
      background-position:center; background-size:cover; background-repeat:no-repeat;
      pointer-events:none; backface-visibility:hidden; transform-style:preserve-3d;
      will-change: transform; transform: translateZ(0); contain: layout paint;
      transition: transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    .page.left { 
      left:0; border-right:1px solid rgba(0,0,0,.06); 
      transform-origin: right center;
    }
    .page.right{ 
      right:0; 
      transform-origin: left center;
    }
    .page.blank{ background:#fff !important; }
    .page.hidden{ visibility:hidden; }

    /* 중앙 스파인 */
    .flipbook::before{
      content:''; position:absolute; top:0; bottom:0; left:50%; width:2px; transform:translateX(-1px);
      background: linear-gradient(180deg, rgba(0,0,0,.12), rgba(0,0,0,0) 40%, rgba(0,0,0,.12));
      opacity:.25; pointer-events:none;
    }

    /* 더 부드러운 그림자 효과 */
    .page.flipping::after{
      content:''; position:absolute; inset:0; pointer-events:none;
      background: linear-gradient(90deg, rgba(0,0,0,.15), rgba(0,0,0,0) 60%);
      opacity: 0;
      transition: opacity 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .page.flipping.shadow::after{
      opacity: 1;
    }

    /* 페이지 뒤집기 상태 */
    .page.turn-right {
      transform: rotateY(-180deg);
      z-index: 10;
    }
    
    .page.turn-left {
      transform: rotateY(0deg);
      z-index: 10;
    }

    .page.preset-left { 
      transform: rotateY(-180deg); 
    }

    .controls{ display:flex; justify-content:center; align-items:center; gap:12px; margin-top:20px }
    .nav-btn{
      background:#fff; color:#e60012; border:none; padding:12px 20px; border-radius:999px; cursor:pointer;
      font-size:15px; font-weight:700; transition: transform .15s ease, box-shadow .15s ease; box-shadow:0 6px 18px rgba(230,0,18,.35);
      user-select:none; -webkit-user-select:none;
    }
    .nav-btn:hover{ transform: translateY(-1px); box-shadow:0 10px 24px rgba(230,0,18,.45); }
    .nav-btn:disabled{ opacity:.5; cursor:not-allowed; transform:none; box-shadow:none }

    .loading{ position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
      background: rgba(255,255,255,.95); z-index:2000; gap:10px }
    .spinner{ width:30px; height:30px; border:3px solid #f3f3f3; border-top:3px solid #e60012; border-radius:50%; animation:spin .8s linear infinite }
    @keyframes spin{ to{ transform: rotate(360deg) } }

    @media (max-width: 768px){ .wrap{width:90vw} .nav-btn{ padding:10px 16px; font-size:14px } }
    @media (prefers-reduced-motion: reduce){ .page{ transition:none !important } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="flipbook" id="flipbook" aria-label="Flipbook">
      <div class="loading" id="loading"><div class="spinner"></div><div>Loading pages…</div></div>
    </div>

    <div class="controls" aria-label="Pagination controls">
      <button class="nav-btn" id="prevBtn">← Previous</button>
      <button class="nav-btn" id="nextBtn">Next →</button>
    </div>
  </div>

  <script>
    const CONFIG = {
      imagePrefix: 'Pg',
      imageExtensions: ['jpg','jpeg','png','webp'],
      maxPagesToCheck: 100,
      loadingTimeout: 5000,
      preloadAhead: 2,
      animationDuration: 600 // ms
    };

    let totalImages = 0, currentSheet = 0, totalSheets = 0, isAnimating = false;
    const sheets = [];
    const preloaded = new Set();

    const $ = s => document.querySelector(s);
    const flipbook = $('#flipbook'), loading = $('#loading');
    const prevBtn = $('#prevBtn'), nextBtn = $('#nextBtn');

    prevBtn.addEventListener('click', previousSheet);
    nextBtn.addEventListener('click', nextSheet);

    document.addEventListener('keydown', e=>{
      if(['ArrowLeft','ArrowUp'].includes(e.key)){ e.preventDefault(); previousSheet(); }
      if(['ArrowRight','ArrowDown'].includes(e.key)){ e.preventDefault(); nextSheet(); }
    });

    flipbook.addEventListener('contextmenu', e=>e.preventDefault());
    document.addEventListener('dragstart', e=>e.preventDefault());

    async function init(){
      const detected = await detectPages();
      if(detected.length === 0){
        loading.innerHTML = `<div style="color:#e74c3c;text-align:center"><strong>No pages found</strong><br>폴더에 <code>${CONFIG.imagePrefix}1.jpg</code>, <code>${CONFIG.imagePrefix}2.jpg</code> … 형태로 배치하세요.<br><small>지원: ${CONFIG.imageExtensions.join(', ')}</small></div>`;
        updateControls(); return;
      }
      totalImages = detected.length;

      // 시트 구성
      sheets.push({ type:'single', align:'right', pages:[ detected[0] ] }); // COVER
      for(let i=1; i<detected.length; i+=2){
        if(i+1 < detected.length){ sheets.push({ type:'spread', pages:[ detected[i], detected[i+1] ] }); }
        else { sheets.push({ type:'single', align:'left', pages:[ detected[i] ] }); } // LAST
      }
      totalSheets = sheets.length;

      // DOM + baseZ 기록
      sheets.forEach((sheet, idx)=>{
        const el = createSheet(sheet);
        const baseZ = 1000 - idx;
        el.style.zIndex = baseZ;
        el.style.visibility = (idx === 0) ? 'visible' : 'visible';
        flipbook.appendChild(el);
        sheet._el = el; sheet.baseZ = baseZ;
      });

      hideAllExcept(currentSheet, currentSheet+1);
      loading.style.display = 'none';
      updateControls();
      preloadAround(currentSheet);
    }

    function createSheet(sheet){
      const el = document.createElement('div');
      el.className = 'sheet';
      if(sheet.type === 'single'){
        const blankSide = sheet.align === 'left' ? 'right' : 'left';
        el.appendChild(makeBlankPage(blankSide));
        el.appendChild(makePage(sheet.pages[0], sheet.align));
      } else {
        el.appendChild(makePage(sheet.pages[0], 'left'));
        el.appendChild(makePage(sheet.pages[1], 'right'));
      }
      return el;
    }

    function makeBlankPage(side){
      const d = document.createElement('div');
      d.className = 'page blank ' + (side==='left' ? 'left' : 'right');
      return d;
    }

    function makePage(data, side){
      const d = document.createElement('div');
      d.className = 'page ' + (side==='left' ? 'left' : 'right');
      d.style.backgroundImage = `url('${data.path}')`;
      return d;
    }

    function updateControls(){
      prevBtn.disabled = (currentSheet <= 0) || isAnimating;
      nextBtn.disabled = (currentSheet >= totalSheets - 1) || isAnimating;
    }

    function hideAllExcept(a, b){
      sheets.forEach((s, i)=>{
        s._el.style.visibility = (i === a || i === b) ? 'visible' : 'hidden';
        resetPages(s._el);
        s._el.style.zIndex = s.baseZ;
      });
    }

    function resetPages(el){
      el.querySelectorAll('.page').forEach(p=>{
        p.classList.remove('hidden','turn-right','turn-left','preset-left','flipping','shadow');
        p.style.transform = '';
      });
    }

    function nextSheet(){
      if(isAnimating || currentSheet >= totalSheets-1) return;
      isAnimating = true; updateControls();

      const curIndex = currentSheet;
      const nxtIndex = currentSheet + 1;
      const cur = sheets[curIndex]._el;
      const nxt = sheets[nxtIndex]._el;

      hideAllExcept(curIndex, nxtIndex);

      const leftCur = cur.querySelector('.page.left'); 
      const rightCur = cur.querySelector('.page.right');
      
      if(!rightCur){ 
        isAnimating=false; updateControls(); return; 
      }

      // 즉시 왼쪽 숨기기
      if(leftCur) leftCur.classList.add('hidden');

      preloadAround(nxtIndex);

      // 부드러운 애니메이션 시작
      rightCur.classList.add('flipping', 'shadow');
      
      // 작은 지연 후 실제 변형 적용
      requestAnimationFrame(() => {
        rightCur.classList.add('turn-right');
      });

      // 애니메이션 완료 대기
      setTimeout(() => {
        cur.style.visibility = 'hidden';
        if(leftCur) leftCur.classList.remove('hidden');
        currentSheet = nxtIndex;
        hideAllExcept(currentSheet, currentSheet+1);
        isAnimating = false; 
        updateControls();
      }, CONFIG.animationDuration);
    }

    function previousSheet(){
      if(isAnimating || currentSheet <= 0) return;
      isAnimating = true; updateControls();

      const prevIndex = currentSheet - 1;
      const prev = sheets[prevIndex]._el;
      const cur = sheets[currentSheet]._el;

      hideAllExcept(prevIndex, currentSheet);

      const curZ = parseInt(cur.style.zIndex, 10) || sheets[currentSheet].baseZ;
      const originalZ = prev.style.zIndex;
      prev.style.zIndex = (curZ + 1).toString();

      const rightCur = cur.querySelector('.page.right');
      const leftPrev = prev.querySelector('.page.left');

      if(!leftPrev){
        prev.style.zIndex = originalZ;
        isAnimating=false; updateControls(); return;
      }

      // 즉시 오른쪽 숨기기
      if(rightCur) rightCur.classList.add('hidden');

      preloadAround(prevIndex);

      // 왼쪽 페이지를 초기 위치(-180도)로 설정
      leftPrev.style.transform = 'rotateY(-180deg)';
      leftPrev.classList.add('flipping', 'shadow');

      // 부드럽게 0도로 회전
      requestAnimationFrame(() => {
        leftPrev.classList.add('turn-left');
      });

      // 애니메이션 완료 대기
      setTimeout(() => {
        cur.style.visibility = 'hidden';
        prev.style.zIndex = originalZ;
        if(rightCur) rightCur.classList.remove('hidden');
        currentSheet = prevIndex;
        hideAllExcept(currentSheet, currentSheet+1);
        
        // 클린업
        leftPrev.classList.remove('preset-left','turn-left','flipping','shadow');
        leftPrev.style.transform = '';
        
        isAnimating = false; 
        updateControls();
      }, CONFIG.animationDuration);
    }

    function preloadAround(index){
      const paths = [];
      for(let d=-CONFIG.preloadAhead; d<=CONFIG.preloadAhead; d++){
        const si = index + d;
        if(si<0 || si>=sheets.length) continue;
        const s = sheets[si];
        if(s.type==='single') paths.push(s.pages[0].path);
        else paths.push(s.pages[0].path, s.pages[1].path);
      }
      paths.forEach(p=>{
        if(preloaded.has(p)) return;
        const im = new Image();
        im.decoding = 'async'; im.loading = 'eager'; im.src = p;
        preloaded.add(p);
      });
    }

    async function detectPages(){
      const found = [];
      for(let i=1;i<=CONFIG.maxPagesToCheck;i++){
        let ok=false, pickedPath='';
        for(const ext of CONFIG.imageExtensions){
          const src = `${CONFIG.imagePrefix}${i}.${ext}`;
          const exists = await checkImage(src);
          if(exists){ ok=true; pickedPath=src; break; }
        }
        if(ok){ found.push({number:i, path:pickedPath}); }
        else if(found.length>0){ break; }
      }
      return found;
    }

    function checkImage(src){
      return new Promise((resolve)=>{
        const img = new Image();
        let done=false;
        const to = setTimeout(()=>{ if(!done){ done=true; resolve(false); } }, CONFIG.loadingTimeout);
        img.onload = ()=>{ if(!done){ done=true; clearTimeout(to); resolve(true); } };
        img.onerror = ()=>{ if(!done){ done=true; clearTimeout(to); resolve(false); } };
        img.src = src + `?v=${Date.now()}`;
      });
    }

    init();
  </script>
</body>
</html>
