<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Flipbook — Simplified</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{font-family:Arial,system-ui;display:flex;align-items:center;justify-content:center;background:#f5f5f7;height:100vh;padding:20px}
  .wrap{width:min(100%,900px)}
  .flipbook{width:100%;aspect-ratio:1.414;background:#fff;border-radius:10px;box-shadow:0 20px 40px rgba(0,0,0,.18);position:relative;perspective:1500px;overflow:visible}
  .spread{position:relative;display:flex;height:100%}
  .page-container{width:50%;position:relative;transform-style:preserve-3d;overflow:hidden}
  .page{position:absolute;inset:0;background-size:cover;background-position:center;background-repeat:no-repeat;backface-visibility:hidden;transform-style:preserve-3d}
  .page.front{z-index:3}
  .page.back{z-index:2;transform:rotateY(180deg)}
  .page.future{z-index:1} /* sits under front/back so visible when top page lifts */
  .page.blank{background:#fff}
  .page-container.left{transform-origin:right center;border-right:1px solid rgba(0,0,0,.06)}
  .page-container.right{transform-origin:left center}
  .page-container.flipping{transition:transform .8s cubic-bezier(.25,.46,.45,.94);z-index:1000}
  .page-container.flip-right{transform:rotateY(-180deg)}
  .page-container.flip-left{transform:rotateY(180deg)}
  .page-container.flipping::after{content:"";position:absolute;inset:0;pointer-events:none;background:linear-gradient(90deg,rgba(0,0,0,0)0%,rgba(0,0,0,0.18)50%,rgba(0,0,0,0)100%);opacity:0;transition:opacity .35s}
  .page-container.flipping.shadow::after{opacity:1}
  .controls{display:flex;gap:12px;justify-content:center;margin-top:18px}
  .btn{background:#fff;border-radius:999px;padding:10px 14px;border:0;box-shadow:0 6px 18px rgba(0,0,0,.08);cursor:pointer;font-weight:700}
  .loading{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.95);z-index:2000}
</style>
</head>
<body>
  <div class="wrap">
    <div class="flipbook" id="flipbook" aria-label="Flipbook">
      <div class="loading" id="loading">Loading…</div>
    </div>
    <div class="controls">
      <button class="btn" id="prev">← Prev</button>
      <button class="btn" id="next">Next →</button>
    </div>
  </div>

<script>
/* CONFIG */
const CONFIG = {
  imagePrefix: 'Pg',
  imageExtensions: ['jpg','jpeg','png','webp'],
  maxPagesToCheck: 200,
  loadingTimeout: 3000,
  preloadAhead: 3,
  animationDuration: 800
};

/* STATE */
let pages = [null]; // pages[1] = Pg1, etc
let totalImages = 0;
let currentSpread = 0; // 0 => cover spread (left blank, right Pg1)
let isAnimating = false;
const preloaded = new Set();

/* DOM helpers */
const $ = s => document.querySelector(s);
const flipbook = $('#flipbook'), loading = $('#loading');
const prevBtn = $('#prev'), nextBtn = $('#next');
prevBtn.addEventListener('click', prevPage);
nextBtn.addEventListener('click', nextPage);
document.addEventListener('keydown', e=>{
  if(e.key === 'ArrowLeft') prevPage();
  if(e.key === 'ArrowRight') nextPage();
});
flipbook.addEventListener('contextmenu', e => e.preventDefault());

/* INIT */
async function init(){
  const found = await detectPages();
  if(found.length === 0){
    loading.innerHTML = `<div style="text-align:center;color:#e22">No pages found. Add images named ${CONFIG.imagePrefix}1.jpg etc.</div>`;
    updateControls();
    return;
  }
  pages = [null];
  found.forEach(p=>pages.push(p.path));
  totalImages = pages.length - 1;
  buildSpreadDOM();
  loading.style.display = 'none';
  updateControls();
  preloadAround(currentSpread);
}

/* Build the two containers (left/right) once */
function buildSpreadDOM(){
  flipbook.innerHTML = '';
  const s = document.createElement('div'); s.className = 'spread';
  s.innerHTML = `
    <div class="page-container left" id="leftContainer"></div>
    <div class="page-container right" id="rightContainer"></div>
  `;
  flipbook.appendChild(s);
  // set initial content
  updateSpreadContent();
}

/* Render front/back and future (next-right) so next-right is already painted */
function updateSpreadContent(){
  const left = $('#leftContainer'), right = $('#rightContainer');
  left.innerHTML = ''; right.innerHTML = '';

  const leftIdx = currentSpread * 2;       // 0 for cover left blank, 2,4...
  const rightIdx = currentSpread * 2 + 1;  // 1 for Pg1, 3,5...

  // left container: front = leftIdx, back = leftIdx + 2 (this back is what would show if that sheet turned)
  appendFrontBack(left, leftIdx, leftIdx + 2);

  // right container: future (next-right) must be appended first (painted under), then front/back on top
  const nextRightIdx = (currentSpread + 1) * 2 + 1;
  if(nextRightIdx <= totalImages && pages[nextRightIdx]){
    const future = document.createElement('div'); future.className='page future';
    future.style.backgroundImage = `url('${pages[nextRightIdx]}${cacheBust()}')`;
    right.appendChild(future);
  } else {
    const future = document.createElement('div'); future.className='page future blank';
    right.appendChild(future);
  }

  appendFrontBack(right, rightIdx, rightIdx + 2);
  // ensure front/back z-order (future under front/back)
}

function appendFrontBack(container, frontIdx, backIdx){
  // FRONT
  const front = document.createElement('div'); front.className='page front';
  if(frontIdx > 0 && frontIdx <= totalImages && pages[frontIdx]){
    front.style.backgroundImage = `url('${pages[frontIdx]}${cacheBust()}')`;
  } else front.classList.add('blank');
  // BACK
  const back = document.createElement('div'); back.className='page back';
  if(backIdx > 0 && backIdx <= totalImages && pages[backIdx]){
    back.style.backgroundImage = `url('${pages[backIdx]}${cacheBust()}')`;
  } else back.classList.add('blank');

  // Append front and back *after* future so they sit on top
  container.appendChild(front);
  container.appendChild(back);
}

/* NAV: flipping - we only toggle classes; DOM already prepared so future page is visible immediately */
function nextPage(){
  if(isAnimating) return;
  const maxSpreads = Math.ceil(totalImages / 2);
  if(currentSpread >= maxSpreads - 1) return;
  isAnimating = true; updateControls();

  const right = $('#rightContainer');
  // make sure right has the 'future' already (updateSpreadContent does this)
  right.classList.add('flipping','shadow','flip-right');
  // allow browser to paint before starting transition
  requestAnimationFrame(()=> requestAnimationFrame(()=>{
    right.classList.add('flip-right'); // double RAF to ensure paint
  }));

  setTimeout(()=>{
    currentSpread++;
    updateSpreadContent(); // prepare next set (including future)
    resetFlipClasses();
    isAnimating = false; updateControls();
    preloadAround(currentSpread);
  }, CONFIG.animationDuration);
}

function prevPage(){
  if(isAnimating || currentSpread <= 0) return;
  isAnimating = true; updateControls();

  const left = $('#leftContainer');
  left.classList.add('flipping','shadow','flip-left');
  requestAnimationFrame(()=> requestAnimationFrame(()=> left.classList.add('flip-left')));

  setTimeout(()=>{
    currentSpread--;
    updateSpreadContent();
    resetFlipClasses();
    isAnimating = false; updateControls();
    preloadAround(currentSpread);
  }, CONFIG.animationDuration);
}

function resetFlipClasses(){
  ['leftContainer','rightContainer'].forEach(id=>{
    const c = document.getElementById(id);
    if(!c) return;
    c.classList.remove('flipping','shadow','flip-left','flip-right');
  });
}

function updateControls(){
  const maxSpreads = Math.ceil(totalImages / 2);
  prevBtn.disabled = (currentSpread <= 0) || isAnimating;
  nextBtn.disabled = (currentSpread >= maxSpreads - 1) || isAnimating;
}

/* Preload images around the spread aggressively */
function preloadAround(spread){
  for(let d=-CONFIG.preloadAhead; d<=CONFIG.preloadAhead; d++){
    const s = spread + d;
    const left = s*2, right = s*2+1;
    [left,right,left+2,right+2].forEach(i=>{
      if(i>0 && i<=totalImages && pages[i] && !preloaded.has(pages[i])){
        const img = new Image();
        img.decoding = 'async';
        img.src = pages[i] + cacheBust();
        preloaded.add(pages[i]);
      }
    });
  }
}

/* Discovery — find Pg1, Pg2, ... in same folder */
async function detectPages(){
  const found = [];
  for(let i=1;i<=CONFIG.maxPagesToCheck;i++){
    let picked = null;
    for(const ext of CONFIG.imageExtensions){
      const src = `${CONFIG.imagePrefix}${i}.${ext}`;
      if(await checkImage(src)){ picked = src; break; }
    }
    if(picked) found.push({number:i,path:picked});
    else if(found.length>0) break;
  }
  return found;
}

/* checkImage uses onload and timeout; keeps cache-bust for testing */
function checkImage(src){
  return new Promise(resolve=>{
    const img = new Image(); let done=false;
    const to = setTimeout(()=>{ if(!done){ done=true; resolve(false); } }, CONFIG.loadingTimeout);
    img.onload = ()=>{ if(!done){ done=true; clearTimeout(to); resolve(true); } };
    img.onerror = ()=>{ if(!done){ done=true; clearTimeout(to); resolve(false); } };
    img.src = src + cacheBust();
  });
}

/* small helper — keep cache busting for dev; remove for prod */
function cacheBust(){ return `?v=${Date.now()}`; }

init();
</script>
</body>
</html>
